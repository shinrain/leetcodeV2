
========================================
(1). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/bipartitieGraph.java
========================================


/*
Given a graph as input, write a java method returning boolean true if the
 graph is bipartitie, else false

 */


Note: this is undirected graph. So define:

graphNode
{
	int val;
	HashSet<Integer> adj;
}


    boolean checkBipartitie(node[] G)
    {
        int n = G.length;
        if(n<=1) return false;
        if(n==2) return true;

		int[] color = new int[n];
		boolean[] visit = new boolean[n];

        LinkedList<node> q = new LinkedList<node>();

        for(int k=0;k<n;k++)
        {
        	if(visit[k]) continue;

        	color[k] = -1;
        	visit[k] = true;
        	if(!dfs(k, G[k], visit, color)) return false;
        }
        return true;
    }

    boolean dfs(int k, node[] G, boolean[] visit, int[] color)
    {
    	for(int i:G[k].adj)
    	{
    		if(visit[i])
    			if(color[i]+color[k]!=0) return false;
    		else
    		{
    			visit[i]=true;
    			color[i] = (color[k]==-1)?1:-1;
    			if(!dfs(i,G,visit,color)) return false;
    		}
    	}
    	return true;
    }
}


========================================
(2). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/byteArrayDecoding.java
========================================



/*
3. 记不清楚了，比较少见的一道题，0, 1开头byte，判断最后一个字符是一个byte还
是两个byte的问题。
*/



    int checkByteArray(Byte[] a)
    {
        int n = a.length;
        if(n==0) return -1;
        if(n==1) return 1;

        if((a[n-1]&(1<<7))!=0) return 2;
        for(int i=n-2;i>0;i--)
        {
            if( (a[i]&(1<<7))==0 ) return ((n-i)%2==1)?2:1;
        }
        if( (a[0]&(1<<7))==0 ) return (n%2==1)?2:1;
        else
            return 2;
    }


========================================
(3). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/convertStringXto10.java
========================================



/*
3. give an input stream like 1010x0x1, give all the result that transfer x into 0 or 1
*/

    List<String> convertStringXto10(String s)
    {
        List<String> re = new ArrayList<String>();
        int n = s.length();
        if(n==0) return re;

         helper(s,0,new char[n], re);
         return re;
    }
    void helper(String s, int k, char[] r, List<String> re)
    {
        if(k==s.length())
        {
            re.add(new String(r));
            return;
        }

        if(s.charAt(k) =='x')
        {
            r[k] = '0';
            helper(s,k+1,r,re);
            r[k] = '1';
            helper(s,k+1,r,re);
        }
        else
        {
            r[k] = s.charAt(k);
            helper(s,k+1,r,re);
        }
    }


========================================
(4). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/destructString.java
========================================



/* Q.Given an input string S write a function which returns true if it satisfies S = nT.
  Basically you have to find if a given string can be represented from a substring by 
  iterating it “n” times. n >= 2
*/


    boolean check(String p, String s)
    {
        int n = p.length(), m = s.length();
        if(n>m) return false;

        for(int i=0;i+n<=m;i+=n)
        {
            if(!p.equals(s.substring(i,i+n))) return false;
        }
        return true;
    }

    int destructString(String s)
    {
        int n = s.length();
        if(n<=1) return -1;

        char piv = s.charAt(0);
        for(int i=1;i<n;i++)
        {
            if(piv==s.charAt(i) && n%(i-0)==0 && check(s.substring(0,i), s.substring(i)))
                return n/i;
        }
        return -1;
    }


========================================
(5). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/doubleDivide.java
========================================


/*Given integer a and b, find out the string representation of a/b. For 
example, if a = 1, b = 3, the output should be 0.(3).
*/


    String divide(int a, int b)
    {
        if(a<b) return "0."+helper(a,b);
        if(a==b) return "1";
        if(a==0) return "0";
        if(b==0) return "NaN";
        if(b==1) return Integer.toString(a);

        return Integer.toString(a/b)+"."+helper(a%b,b);
    }

    String helper(int a, int b)
    {
        if(a>=b) return Integer.toString(a%b);

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        LinkedList<Integer> re = new LinkedList<Integer>();


        while(a!=0)
        {
            a*=10;
            while(a<b)
            {
                a*=10;
                re.add(0);
            }
            int val = a/b;
            map.put(a/10,val);
            re.add(val);
            a = a%b;
            if(map.containsKey(a)) break;
        }
        String result = "";
        if(a==0)
            for(int i:re) result+=Integer.toString(i);
        else
        {
            int bug = map.get(a);
            for(int i:re)
            {
                if(i==bug) result+=("(");
                result+=Integer.toString(i);
            }
            result+=")";            
        }
        return result;
    }


========================================
(6). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/equalZeroOnes.java
========================================


/*
Google:

2. an array with 0's and 1's, find in O(n) time and O(1) space the longest 
sequence with equal number of 1's and 0's.

can do it with O(n) time and O(n) space. How to do O(1) space.
*/

import java.util.*;
import java.lang.*;

class Solution
{
	int equalZeroOnes(int[] a)
	{
		int n = a.length;
		if(n<=1)  return 0;

		int[] sum = new int[n];
		Map<Integer, Integer> map = new HashMap<>();
		map.put(0,-1);
		sum[0] = (a[0]==0)?-1:1;
		for(int i=1;i<n;i++)
		{
			if(a[i]==0) sum[i] = sum[i-1]-1;
			else
				sum[i] = sum[i-1]+1;
		}
		int max = 0;

		for(int i=0;i<n;i++)
		{
			if(!map.containsKey(sum[i])) map.put(sum[i],i);
			else
			{
				int local = i-map.get(sum[i]);
				if(local>max) max = local;
			}
		}
		return max;
	}
	public static void main(String[] args) {
		int[] a = {0,0,1,1,1,1,0,0,0,1,1,0};
		System.out.println(new Solution().equalZeroOnes(a));
	}
}



========================================
(7). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/findGlobalMax.java
========================================


/*
Second interviewer gave me array, with elements first strictly increasing, then strictly
decreasing. Asked me to find the largest number. 
*/

    int findGlobalMax(int[] a)
    {
        int n = a.length;
        if(n<3) return -1;

        int l = 0, r = n-1;
        while(l<=r)
        {
            int mid = l+(r-l)/2;
            if(mid==0) l++;
            else if(mid==n-1) r--;
            else
            {
                if(a[mid-1]<a[mid] && a[mid+1]<a[mid]) return a[mid];
                else if(a[mid-1]<a[mid]) l =mid+1;
                else r = mid-1;
            }
        }
        return -1;
    }


========================================
(8). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/findMaxPairStringNoCommonChar.java
========================================



/*
2. Given a list of words, find two strings S & T such that:
    a. S & T have no common character
    b. S.length() * T.length() is maximized
*/


    static class wrapper implements Comparable
    {
        String s;
        wrapper(String _s)
        {
            s = _s;
        }

        public int compareTo(Object o)
        {
            return -(s.length()-((wrapper)o).s.length());
        }
    }

    boolean checkCommon(String S, String T)
    {
        int m = S.length(), n = T.length();
        if(m*n==0) return true;

        int i =0, j=0;
        while(i<m&&j<n)
        {
            if(S.charAt(i)<T.charAt(j)) i++;
            else if(S.charAt(i)>T.charAt(j)) j++;
            else return true;
        }
        return false;
    }

    int findMaxPairStringNoCommonChar(String[] str)
    {
        int n = str.length;
        if(n<=1) return 0;

        wrapper[] tmp = new wrapper[n];
        for(int i=0;i<n;i++)
        {
            char[] t = str[i].toCharArray();
            Arrays.sort(t);
            str[i] = new String(t);
            tmp[i] = new wrapper(str[i]);
        }
        Arrays.sort(tmp);
        for(int i=0;i<n;i++)
            str[i] = tmp[i].s;

        int max = Integer.MIN_VALUE;
        int upper = n;
        for(int i=0;i<upper;i++)
        {
            for(int j=i+1;j<upper;j++)
            {
                if(!checkCommon(str[i],str[j]))
                {
                    if(str[i].length()*str[j].length() >max)
                    {
                        max = str[i].length()*str[j].length();
                        upper = j;
                        break;
                    }
                }
            }
        }
        return max;
    }


========================================
(9). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/findPolice.java
========================================



/*
其他都比较常规，有一道图的题目，一个 n*n 矩阵，每个房间可能是封闭的房间，可
能是警察，可能是开的房间，封闭的房间不能过，返回一个 n*n矩阵， 每一个元素是
最近的警察到这个房间的最短距离。
*/


==

    int[][] findPolice(int[][] houses)
    {
        int m = houses.length;
        if(m==0) return null;
        int n = houses[0].length;
        if(n==0) return null;

        int[][] re = new int[m][n];
        boolean[][] visit = new boolean[m][n];
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                if(houses[i][j] ==-1) visit[i][j] = true;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(houses[i][j] == 0)
                {
                    visit[i][j] = true;
                    re[i][j] = helper(houses, i, j, visit);
                    visit[i][j] = false;
                }
            }
        }
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
                System.out.print(re[i][j]+" ");
            System.out.println();
        }
        return re;
    }

    int helper(int[][] houses, int i, int j, boolean[][] visit)
    {
        if(houses[i][j]==1) return 0;
        if(houses[i][j]==-1) return -1;
        int min = Integer.MAX_VALUE;
        if(i-1>=0 && !visit[i-1][j] )
        {
            visit[i-1][j] = true;
            int t = helper(houses, i-1, j, visit);
            if(t!=-1 && t+1<min)
            {
                min = t+1;
            }
            visit[i-1][j] =false;
        }

        if(i+1<houses.length && !visit[i+1][j])
        {
            visit[i+1][j] = true;
            int t = helper(houses, i+1, j, visit);
            if(t!=-1 && t+1<min)
            {
                min = t+1;
            }
            visit[i+1][j] = false;
        }
        if(j-1>=0 && !visit[i][j-1])
        {
            visit[i][j-1] = true;
            int t = helper(houses, i, j-1, visit);
            if(t!=-1 && t+1<min)
            {
                min = t+1;
            }
            visit[i][j-1] = false;
        }
        if(j+1<houses[0].length && !visit[i][j+1])
        {
            visit[i][j+1] = true;
            int t = helper(houses, i, j+1, visit);
            if(t!=-1 && t+1<min)
            {
                min = t+1;
            }
            visit[i][j+1] = false;
        }
        if(min==Integer.MAX_VALUE) min = -1;
        return min;
    }

=========
BFS solution, which is better

static class pair
{
	int a, b;
	pair(int _a, int _b)
	{
		a = _a; b = _b;
	}
}
 int[][] findPolice(int[][] houses)
 {
 	int m = houses.length;
 	if(m==0) return null;
 	int n = houses[0].length;
 	if(n==0) return null;

 	
 	int[][] re = new int[m][n];
 	for(int i=0;i<m;i++)
 	{
 		for(int j=0; j<n; j++)
 		{
 			if(houses[i][j] == 0)
 			{
 				boolean[][] visit = new boolean[m][n];
 				visit[i][j] = true;
 				re[i][j] = bfs(houses, visit, i, j);
 				visit[i][j] = false;
 			}
 		}
 	}
 	return re;
 }

 int bfs(int[][] houses, boolean[][] visit, int i, int j)
 {
 	int m = houses.length, n = houses[0].length;
 	if(i>=m || j>=n) System.exit(-1);
 	LinkedList<pair> q = new LinkedList<>();
 	q.add(new pair(i,j));
 	int re = 0;
 	while(q.size()!=0)
 	{
 		int siz = q.size();
 		for(int ii=0; ii<siz; ii++)
 		{
 			pair cur = q.removeFirst();
 			if(houses[cur.a][cur.b]==1) return re;
 			if(cur.a+1<m && houses[cur.a+1][cur.b] !=-1 && !visit[cur.a+1][cur.b])
 			{
 				visit[cur.a+1][cur.b] = true; q.addLast(new pair(cur.a+1, cur.b));
 			}
 			if(cur.b+1<n && houses[cur.a][cur.b+1] !=-1 && !visit[cur.a][cur.b+1])
 			{
 				visit[cur.a][cur.b+1] = true; q.addLast(new pair(cur.a, cur.b+1));
 			}
 			if(cur.a-1>=0 && houses[cur.a-1][cur.b] !=-1 && !visit[cur.a-1][cur.b])
 			{
 				visit[cur.a-1][cur.b] = true; q.addLast(new pair(cur.a-1, cur.b));
 			}
 			if(cur.b-1>=0 && houses[cur.a][cur.b-1] !=-1 && !visit[cur.a][cur.b-1])
 			{
 				visit[cur.a][cur.b-1] = true; q.addLast(new pair(cur.a, cur.b-1));
 			}
 		}
 		re++;
 	}
 	return 0;
 }


=========   

 public static void main(String[] args) {
 	int[][] houses = {{0,0,-1,0},{-1,-1,1,0},{-1,0,0,1},{1,0,-1,1}};
 	int[][] re = new Solution().findPolice(houses);
 	for(int[] a:houses)
 	{
 		for(int i:a)
 			System.out.print(i+" ");
 		System.out.println();
 	}
 	System.out.println();
 	for(int[] a:re)
 	{
 		for(int i:a)
 			System.out.print(i+" ");
 		System.out.println();
 	}
 }
}



========================================
(10). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/findRangeBST.java
========================================



/*
In a given binary search tree, find the number of elements that lie in a given range.
*/

List<Integer> findNumInRange(TreeNode root, int min, int max)
{
	List<Integer> re = new ArrayList<>();
	helper(root, min, max);
	return re;
}

void helper(TreeNode root, int min, int max, List<Integer> re)
{
	if(root==null) return;
	else if(root.val<=min) helper(root.right, min, max, re);
	else if(root.val>=max) helper(root.left, min, max, re);
	else
	{
		re.add(root.val);
		helper(root.right, min, max, re);
		helper(root.left, min, max, re);
	}
}



========================================
(11). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/findRotation.java
========================================


Given a rotated array, find the number of rotation

======

	public int findTotate(int[] a)
	{
		int n = a.length;
		if(n<=1) return 0;

		int l = 0, r = n-1;
		int re = -1;
		while(l<r)
		{
			int mid = l+(r-l)/2;
			if(a[mid]>a[l] && a[mid]>=a[r])
			{
				re = mid;
				l = mid;
			}else if(a[mid]<a[l] && a[mid]<=a[r])
			{
				re=mid;
				r = mid;
			}
			else
			{
				l++;
			}
		}
		return (re==-1)?0:re;
 	}


========================================
(12). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/inversionCount.java
========================================


/*
   Count inversion number in unsorted array:
   {3,1,2} -> 2, since {3,1}, {3,2}
*/


    int merge(int[] a, int l, int r, int[] c)
    {
        if(l>=r) return 0;
        int mid = l +(r-l)/2;
        int i=l, j = mid+1, k=0;
        int left = merge(a,l,mid,c);
        int right = merge(a,mid+1,r,c);
        int inversion = 0;
        while(i<=mid&&j<=r)
        {
            if(a[i]<=a[j])
            {
                c[k++] = a[i++];
            }
            else
            {
                c[k++] = a[j++];
                inversion+=(j-mid);
            }
        }
        if (i<=mid) c[k++] = a[i++];
        while(i<=mid)
        {
            c[k++] = a[i];
            inversion += (r-mid);
            i++;
        }
        while(j<=r) 
        {
            c[k++] = a[j++];
            
        }
        i=l;

        for(int in=0; in<k;in++)
        {
            a[i++] = c[in];
        }
        return inversion+left+right;
    }



========================================
(13). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/isBuidableSoda.java
========================================


/*
A soda water machine,press button A can generate 300-310ml, button B can generate 400-420ml and button C can generate 
500-515ml, then given a number range [min, max], tell if all the numers of water in the range can be generated. 

range DP.??
*/

public static boolean isBuidable(int low, int high, int min, int max) {
    
    if(low <= min && max <= high)
      return true;
    
    if(low > min) 
      return false;
    
    return isBuidable(low+300, high+310, min, max) ||
         isBuidable(low+400, high+420, min, max) ||
         isBuidable(low+500, high+515, min, max);
  }


========================================
(14). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/longestCircleIndex.java
========================================


/*
索引 0 1 2 3 4
值   3 2 1 4 0
数组的值是下次跳的索引位置，这样的话数组有环，比如 0 -> 3 -> 4 -> 0  1 -> 2 
-> 1， 求最长环的长度.
*/

    int detect(int next, HashMap<Integer, Integer> map)
    {
        int re = 1;
        int cur = next;
        while(map.containsKey(cur))
        {
            cur = map.get(cur);
            re++;
            if(cur == next) break;
        }
        return re;
    }

    int longestCircle(HashMap<Integer, Integer> map)
    {
        HashSet<Integer> set = new HashSet<Integer>();
        int max = 0;

        while(map.size()!=0)
        {
            set.clear();
            for(int i:map.keySet())
            {
                if(set.contains(i)) continue;

                int cur = i;
                while(!set.contains(cur) && map.keySet().contains(cur))
                {
                    set.add(cur);
                    int next = map.get(cur);
                    if(!set.contains(next)) cur = next;
                    else
                    {
                        int local = detect(next, map);
                        if(local > max) max = local;
                        for(int j:set)
                            map.remove(j);
                        break;
                    }
                }
                break;
            }
        }
        return max;
    }


===
Another cleaner solution:

		int longestCircleIndex(int[] a)
	{
		int n = a.length;
		if(n<=1) return n;

		Map<Integer, Integer> map = new HashMap<>();
		for(int i=0;i<n;i++)
		{
			map.put(i, a[i]);
		}

		
		int max = 0;


		Set<Integer> set = new HashSet<>(map.keySet());
		for(int i:set)
		{
			if(!map.containsKey(i)) continue;
			int local = dfs(map, i);
			if(local > max) max = local;
		}
		return max;
	}

	int dfs(Map<Integer, Integer> map, int i)
	{
		if(!map.containsKey(i)) return 0;
		int re = 0;
		int cur = i;
		int local = 0;
		while(!map.isEmpty())
		{
			if(!map.containsKey(cur)) break;
			local++;
			int t = cur;
			cur = map.get(cur);
			map.remove(t);
			if(cur==i)
			{
				if(re<local) re = local;
				break;
			}
		}
		return re;
	}




========================================
(15). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/longestCommonSuffix.java
========================================



/*
longest common suffix of two linked list
*/
    ListNode reverse(ListNode head)
    {
        if(head==null || head.next ==null) return head;
        ListNode cur = head;
        head = null;
        while(cur!=null)
        {
            ListNode t = cur.next; t.next = null;
            cur.next = head; head = cur;
            cur = t;
        }
        return head;
    }

    ListNode longestCommonSuffix(ListNode n1, ListNode n2)
    {
        if(n1==null || n2==null) return null;

        n1 = reverse(n1);
        n2 = reverse(n2);

        ListNode head = null, tail = null;
        while(n1!=null && n2!=null)
        {
            if(n1.val==n2.val)
            {
                ListNode t = new ListNode(n1.val);
                if(head==null)
                {
                    head = t; tail = t;
                }
                else
                {
                    tail.next = t; tail  = t;
                }
            }
            n1 = n1.next; n2 = n2.next;
        }
        return reverse(head);
    }



========================================
(16). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/longestSubstringOfTwoChars.java
========================================


/*
given a string ,return the longest substring that contains at most two 
characters.
*/
    String longestSubstringOfTwoChars(String s)
    {
        int n = s.length();
        if(n<=2) return s;

        char[] c = s.toCharArray();
        int i=0, j=0;

        int start = 0, end = 0;

        for(;j<n && c[j]==c[i];j++);
        if(j==n) return s;

        char a = c[i], b = c[j];
        for(;j<n;j++)
        {
            if(c[j]==a || c[j]==b) continue;

            if(j-i>end-start+1)
            {
                start = i; end = j-1;

            }

            i=j-1;
            while(i>=0 && c[i]==c[j-1]) i--;
            if(i<0) return s.substring(start, end+1);
            i++;
            a = c[i]; b=c[j];
        } 
        if(j-i>end-start+1) { start = i; end = j-1; }
        return s.substring(start, end+1);
    }

    public static void main(String[] args) {
        System.out.println(new Solution().longestSubstringOfTwoChars("aabbbbbaxbbbaanaaaaaaaaax"));
    }



=====

Another solution:

Note: if calculate the effective length for each valid char, a final check is not needed.

int longestSubstringOfTwoChars(String s)
{
	char[] a = s.toCharArray();
	int n = a.length;
	if(n<=2) return n;

	int i=0, j=0;
	int fst = a[i], snd = 0;

	int max = 0, start = 0, end = 0;
	while(j<n && a[j]==fst) j++;
	if(j==n) return n;

	snd = a[j];
	while(j<n&&a[j]==snd) j++;
	if(j==n) return n;

	while(j<n)
	{
		if(a[j] == fst || a[j] == snd)
		{
			if(j-i+1>max)
			{
				max = j-i+1;
				start = i; end = j+1;
			}
		}
		else
		{
			i=j-1;
			while(i>=0&&a[i]==a[j-1]) i--;
			i++;
			fst = a[i]; snd = a[j];
		}
		j++;
	}
	System.out.println(s.substring(start, end));
	return max;
}



========================================
(17). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/meanOfKinStream.java
========================================


Design a class where you can add elements, and return the mean of the latest N elements.



class Kmean
{
	int cap;
	int siz;
	int sum;
	int cur;
	int[] arr;
	Kmean(int _cap)
	{
		cap = _cap;
		cur = siz = sum = 0;
		arr = new int[cap];
	}

	void put(int val)
	{
		if(siz<cap)
		{
			arr[cur] = val;
			sum+=val;
			size++;
			cur = (cur+1)%cap;
		}
		else
		{
			sum -=arr[cur];
			arr[cur] = val;
			sum+=arr[cur];
			cur = (cur+1)%cap;
		}
	}

	int getMean()
	{
		return sum/siz;
	}
}

====

This is cleaner

class Kmean
{

	int[] a;
	int cap = 10;
	int ind;
	int siz;
	int sum;

	void put(int val)
	{
		sum-=a[ind%cap];
		sum+=val;
		a[ind%cap] = val;
		ind++;
		if(siz<cap) siz++;
	}

	int getMean()
	{
		if(siz==0) System.exit(0);
		return sum/siz;
	}

}



========================================
(18). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/minConvertPalindrome.java
========================================


/*
Given a string, convert it into a palindrome with the lease number of insertions possible
*/


===
if just compute the minimum # of insertions, iterative DP is good:

int minConvertPalindrome(String s)
{
	int n = s.length();
	if(n<=1) return 0;

	int[][] map = new int[n][n];
	for(int j=0;j<n;j++)
	{
		for(int i=j-1;i>=0;i--)
		{

			if(s.charAt(i)!=s.charAt(j))
			{
				if(i+1>=j) map[i][j] = 1;
				else
				{
					map[i][j] = Math.min(map[i+1][j], map[i][j-1])+1;
				}
			}
			else
			{
				if(i+1>=j-1) map[i][j] = 0;
				else
					map[i][j] = map[i+1][j-1];
			}

		}
	}
	for(int[] i:map)
	{
		for(int j:i)
			System.out.print(j+" ");
		System.out.println();
	}
	return map[0][n-1];
}




===
    static class Result
    {
        int num;
        String s;
        Result(int _num, String _s)
        {
            num = _num; s=_s;
        }
        public String toString()
        {
            return "{"+num+", "+s+"}";
        }
    }
    String minPalindrome(String s)
    {
        int n = s.length();
        if(n<=1) return s;

        Result re = helper(s, 0, n-1, new HashMap<Integer, Result>());
        System.out.println(s);
        System.out.println(re.num);
        return re.s;
    }

    Result helper(String s, int l, int r, HashMap<Integer, Result> map)
    {
        if(l>r)
        {
            Result re = new Result(0,"");
            return re;
        }
        if(l==r)
        {
            Result re = new Result(0, s.substring(l,l+1));
            return re;
        }

        int key = l*s.length()+r;
        if(map.containsKey(key)) return map.get(key);

        Result re = null;

        Result left = helper(s,l,r-1,map);
        Result right = helper(s,l+1,r,map);

        if(left.num<right.num)
        {
            re = new Result(left.num+1, s.charAt(r)+left.s+s.charAt(r));
        }
        else
        {
              re = new Result(right.num+1, s.charAt(l)+right.s+s.charAt(l));
        }

        if(s.charAt(l)==s.charAt(r))
        {
            Result tmp = helper(s,l+1,r-1,map);

            if(tmp.num<re.num)
            {
                re.num = tmp.num; re.s = tmp.s;
                re.s = s.charAt(l)+re.s+s.charAt(l);
            }
        }

        map.put(key, re);
        return re;
    }



========================================
(19). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/minLenOfSquareSum.java
========================================


/*	Input: 38
	Output: [2,3,5], since 2^2+3^2+5^2 = 38*/

===

Iteration:
====

Cleaner solution:

List<Integer> minLenOfSquareSum(int num)
{
	List<Integer> re = new ArrayList<>();
	if(num<1) return re;

	int[] minimum = new int[num+1];
	int[] pred = new int[num+1];

	Arrays.fill(minimum, Integer.MAX_VALUE);
	Arrays.fill(pred, -1);

	for(int i=1;i<=num;i++)
	{
		int sroot = (int)Math.sqrt(i);
		if(sroot*sroot==i)
		{
			minimum[i] = 1;
			pred[i] = sroot;
		}
		else
		{
			int min = Integer.MAX_VALUE;
			int pre = -1;
			for(int j=sroot; j>0; j--)
			{
				int comp = i-j*j;
				if(minimum[comp]<min)
				{
					min = minimum[comp];
					pre = j;
				}
			}
			minimum[i] = min+1;
			pred[i] = pre;
		}
	}

	return getSequence(pred);
}

List<Integer> getSequence(int[] pred)
{
	List<Integer> re = new ArrayList<>();

	int cur = pred.length-1;
	System.out.println(cur);
	while(pred[cur]!=-1)
	{
		re.add(pred[cur]);
		cur-=(pred[cur]*pred[cur]);
	}
	return re;
}



====
    List<Integer> shortestSquareSum(int N)
    {
        List<Integer> result = new ArrayList<Integer>();

        if(N<0) return result;
        if(N<=1) { result.add(N); return result;}

        int n = (int)(Math.sqrt(N));

        if(n==-1) return result;

        int[][] prefix = new int[n][N];
        int[][] arr = new int[n][N];
        for(int i=0;i<n;i++)
            for(int j=0;j<N;j++)
                arr[i][j] = Integer.MAX_VALUE;
        for(int i=0;i<n;i++)
            for(int j=0;j<N;j++)
                prefix[i][j] = -1;


        for(int i=0;i<N;i++)
        {
            
            for(int j = n-1;j>=0;j--)
            {
                int cur = (j+1)*(j+1);
                int min = Integer.MAX_VALUE;
                int pre = -1;
                if(cur>i+1) continue;
                else if(cur==i+1) { min = 1; pre = -1;}
                else
                {
                    int val = i+1-cur;
                    for(int k = j;k>=0;k--)
                    {
                        if(arr[k][val-1]!= Integer.MAX_VALUE && arr[k][val-1]+1<min)
                        {
                            min = arr[k][val-1]+1;
                            pre = k;
                        }
                    }
                }
                arr[j][i] = min;
                prefix[j][i] = pre;
            }
        }

        int ind=-1;
        int min = Integer.MAX_VALUE;
        for(int i=0;i<n;i++)
            if(arr[i][N-1]<min)
            {
                min = arr[i][N-1];
                ind = i;
            }
        if(min==Integer.MAX_VALUE) return null;

        result = new ArrayList<Integer>();
        int res = N-1;
        while(ind!=-1)
        {
            result.add(ind+1);
            int t = ind;
            ind = prefix[ind][res];
            res = res-(t+1)*(t+1);
        }
        return result;
    }

====

Recursion:

	List<Integer> helper(int target, int max, HashMap<Integer, List<Integer>> map, int magic)
	{
		if(target==0) return new ArrayList<Integer>();
		if(target<0 || max<=0)
		{
			return null;
		}
		int sqrt = (int)Math.sqrt(target);
		int upper = Math.min(sqrt, max);
		if(upper==0)
		{
			return null;
		}

		int key = max*magic+target;
		if(map.containsKey(key))
		{
			return map.get(key);
		}

		List<Integer> rr = helper(target, upper-1, map, magic);
		int min = -1;
		int siz = -1, minCount = 0;
		if(rr==null)
		{
			siz = 0;
			min = Integer.MAX_VALUE;
		}
		else
		{
			siz = rr.size();
			min = rr.size();
		}
		int prod = upper*upper;
		int count = 0;
		while(target - prod>=0)
		{
			target -=prod;
			count++;

			List<Integer> rr_local = helper(target,upper-1, map, magic);
			if(rr_local == null) continue;

			if(rr_local.size()+count<min)
			{

				rr = rr_local;
				minCount = count;
				min = rr.size()+count;
			}
		}
		List<Integer> re = new ArrayList<Integer>(rr);
		for(int i=0;i<minCount;i++)
			re.add(upper);
		map.put(key, re);
		return map.get(key);
	}

	List<Integer> minFactorization(int a)
	{
		List<Integer> re = new ArrayList<Integer>();
		if(a<=0) return re;
		if(a == 1)
		{
			re.add(1); return re;
		}

		int magic = (int)(Math.sqrt(a));

		return helper(a, magic, new HashMap<Integer, List<Integer>>(), a);

	}

	===

	Recursion 2:
	    List<Integer> shortestSquareSum(int N)
    {
        List<Integer> result = new ArrayList<Integer>();

        if(N<0) return result;
        if(N<=1) { result.add(N); return result;}

        int re = -1;
        int l = 1, r = N;
        while(l<=r)
        {
            int mid = l+(r-l)/2;
            if(N/mid == mid) { re = mid; break;}
            else if(N/mid < mid) { r = mid-1; }
            else { re = mid; l = mid+1;}
        }

        if(re==-1) return result;

        int n = re;
        int[] arr = new int[n];
        for(int i=0;i<n;i++)
            arr[i] = (i+1)*(i+1);

        for(int i:arr)
            System.out.print(i+" ");
        System.out.println();
        HashMap<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        return helper(arr, 0, N,map);
    }

    List<Integer> helper(int[] arr, int k, int sum, HashMap<Integer, List<Integer>> map)
    {
        
        if(sum==0) return new ArrayList<Integer>();
        if(k==arr.length || sum<0 || arr[k]>sum) return null;


        int key = arr.length*sum+k;
        if(map.containsKey(key)) return map.get(key);


        List<Integer> list = helper(arr, k+1, sum, map);
        int min = (list==null)?Integer.MAX_VALUE:list.size();

        int count = 0;
        int minCount = 0;
        while(sum-arr[k]>=0)
        {
            count++;
            sum-=arr[k];
            List<Integer> tmp = helper(arr, k+1, sum, map);
            if(tmp!=null && (tmp.size()+count<min||list==null))
            {
                list = tmp;
                min = tmp.size()+count;
                minCount = count;
            }
        }
        
        if(list==null || min==Integer.MAX_VALUE) return null;
        
        List<Integer>re = new ArrayList<Integer>(list);
        int sqt = (int)Math.sqrt(arr[k]);
        for(int i=0;i<minCount;i++)
            re.add(sqt);
        map.put(key, re);

        return re;
    }



========================================
(20). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/minPartition.java
========================================


/*
Given n numbers (P1,P2,P3,.....Pn). Divide them in m contiguous partitions such that the sum of the maximum is minimum.
For e.g. (5,1,4,2,3) and m =2
then (5,1)(4,2,3)  
*/



    List<List<Integer>> minPartition(int[] a, int m)
    {
        int n = a.length;
        if(n<m) return 0;

        int[][] min = new int[n][m];
        int[][] prefix = new int[n][m];

        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
            {
                min[i][j] = Integer.MAX_VALUE;
                prefix[i][j] = -1;
            }
       
        int sum = a[0];

        min[0][0] = a[0];
        for(int i=1;i<n; i++)
            min[i][0] = min[i-1][0]+a[i];

        for(int i=1;i<n;i++)
        {

            sum+=a[i];
            for(int j=1;j<m&&j<=i;j++)
            {
                int sub = 0; int pre = -1;
                int minimum = Integer.MAX_VALUE;
                for(int k = i;k>=j;k--)
                {
                    sub+=a[k];

                    if(Math.max(sub, min[k-1][j-1]) < minimum)
                    {
                        minimum = Math.max(sub, min[k-1][j-1]);
                        pre = k-1;
                    }
                }
                min[i][j] = minimum;
                prefix[i][j] = pre;
            }
        }
        List<List<Integer>> re = new ArrayList<List<Integer>>();
        int cur = n-1;
        int count = m-1;
        while(cur!=-1)
        {
            int pre = prefix[cur][count];
            List<Integer> rr = new ArrayList<Integer>();
            for(int i = pre+1;i<=cur;i++)
                rr.add(a[i]);
            re.add(rr);
            count--;
            cur = pre;
        }
        return re;
    }


========================================
(21). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/mostTimeinArray.java
========================================



/*
find out in a sorted array which number appears the most times
*/

    int mostTimeinArray(int[] a)
    {
        int n = a.length;
        if(n<=1) return n;

        int max = 0;
        int i = 0;
        while(i<n)
        {

            int l = i, r = n-1;
            int re = -1;
            while(l<=r)
            {
                int mid = l+(r-l)/2;
                if(a[mid]==a[i])
                {
                    re = mid; l = mid+1;
                }
                else if(a[mid]>a[i]) r = mid-1;
                else l = mid+1;
            }
            if(re==-1) break;
            if(re+1-i>max) max = re+1-i;
            i = re+1;

        }
        return max;
    }


========================================
(22). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/Ramanujan.java
========================================


/*
Question 1: The interviewer was really kind. The asked me to write a function to find all the Ramanujan numbers. He helped
 me when I got stuck at any point and was giving me polite hints.

 1729 = 1^3 + 12^3 = 9^3 + 10^3
*/
    List<List<Integer>> Ramanujan(int N)
    {
        List<List<Integer>> re = new ArrayList<List<Integer>>();
        if(N<9) return re;
        long l = 1, r = N;
        while(l<r)
        {
            long sum = l*l*l+r*r*r;
            if(sum == N)
            {
                List<Integer> rr = new ArrayList<Integer>();
                rr.add((int)l); rr.add((int)r);
                re.add(rr);
                if(re.size()==2) return re;
                else { l++;r--;}
            }
            else if(sum<N) l++;
            else r--;
        }
        re.clear();
        return re;
    }


========================================
(23). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/randomCache.java
========================================



/*就是如何实现find, insert, delete, getRandom 都是O(1)
*/



class Solution
{
    int cap;
    int size;
    int[] arr;
    HashMap<Integer, Integer> map;

    Solution(int _cap)
    {
        cap = _cap;
        size = 0;
        arr = new int[cap];
        map = new HashMap<Integer, Integer>();
    }

    boolean find(int elem)
    {
        return map.containsKey(elem);
    }

    void insert(int elem)
    {
        if(map.containsKey(elem)) return;
        if(size<cap)
        {
            arr[size] = elem;
            map.put(elem, size);
            size++;
        }
        else
        {
            int[] newArr = new int[2*cap];
            for(int i=0;i<cap;i++)
            {
                newArr[i] = arr[i];
            }
            cap = 2*cap;
            insert(elem);
        }
    }
    
    void delete(int elem)
    {
        if(!map.containsKey(elem)) return;

        int ind = map.get(elem);
        int last = arr[size-1];
        map.remove(elem);
        map.remove(last);
        arr[ind] = last;
        map.put(last,ind);
        size--;
    }

    int getRandom()
    {
        if(size!=0)
        {
            int k = random(0,size);
            return arr[k];
        }
        System.exit(-11);
    }
}



========================================
(24). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/randomWalkProb.java
========================================



/*
第二题，直线上有一个机器人从原点开始移动，每次可以向左移，也可以向右移，移动
n步，再回到原点的概率是多少, 可以写程序实现。*/

    static class returnType
    {
        int origin;
        int total;
        returnType()
        {
            origin = 0; total = 0;
        }
    }

    returnType helper(int n, int i, int j)
    {
        if(i+j>n) return new returnType();
        int origin = 0;
        int total = 0;
        if(i+j==n)
        {
            if(i==j) origin++;
            total++;
        }
        else
        {
            returnType res1=helper(n,i+1,j);
            returnType res2=helper(n,i,j+1);
            origin = res1.origin+res2.origin;
            total = res1.total+res2.total;
        }

        returnType re= new returnType();
        re.origin = origin;
        re.total = total;
        return re;
    }



========================================
(25). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/rebuildAlphabet.java
========================================


/*
fft, fcp, aac, act, acd, atp, tbk, tdf, …
这些都是按照字母排序好的，但是字母顺序改了，比如 f 在 a之前，t在d之前等等，
给定一些这样的rule，问怎么rebuild the alphabet?
*/



class node
{
    char val;
    int indegree;
    HashSet<node> outNode;

    node(char _val)
    {
        val = _val;
        indegree = 0;
        outNode = new HashSet<node>();
    }
}

class Solution{


    String alphabetRebuild(String[] a)
    {
        String re = "";
        int n = a.length;
        if(n==0) return re;

        HashMap<Character, node> map = new HashMap<Character, node>();

        for(String s:a)
        {
            for(int i=0;i<s.length();i++)
            {
                char c = s.charAt(i);
                if(!map.containsKey(c))
                {
                    map.put(c, new node(c));
                }

                if(i+1<s.length())
                {
                    char next = s.charAt(i+1);

                    if(next==c) continue;

                    node nd = map.get(c);

                    if(!map.containsKey(next))
                        map.put(next,new node(next));

                    if(!nd.outNode.contains(map.get(next)))
                    {
                        map.get(next).indegree++;
                        nd.outNode.add(map.get(next));
                    }
                }
            }
        }

        while(map.size()!=0)
        {
            node nd = null;
            for(char c:map.keySet())
            {
                nd = map.get(c);
                if(map.get(c).indegree==0) break;
            }

            if(nd==null) return re;
            re = re+String.valueOf(nd.val);
            for(node N : nd.outNode)
            {
                N.indegree--;
            }
            map.remove(nd.val);
        }
        return re;
    }

    public static void main(String[] args) {
        
        String[] a = {"fft", "fcp", "aac", "act", "acd", "atp", "tbk", "tdf"};

        System.out.println(new Solution().alphabetRebuild(a));
    }

}


========================================
(26). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/rebuildUpTree.java
========================================


/* 1. printing a tree structure with giving collection of pairs of <parent, 
child> relation. Need to first find the root, and validate wether the given 
relations is a valid tree, and then printing. 
*/

===
    static class pair
    {
        int left, right;
        pair(int _left, int _right)
        {
            left = _left; right = _right;
        }
    }

    static class node
    {
        int val;
        int indegree;
        HashSet<node> outgoing;
        node(int _val)
        {
            val = _val; indegree = 0; outgoing = new HashSet<node>();
        }
    }

    node buildUp(pair[] a)
    {
        int n = a.length; 
        if(n==0) return null;

        HashMap<Integer, node> map = new HashMap<Integer, node>();
        for(pair p:a)
        {
            int par = p.left, kid = p.right;
            if(!map.containsKey(par)) map.put(par, new node(par));
            if(!map.containsKey(kid)) map.put(kid, new node(kid));
            node parNode = map.get(par);
            node kidNode = map.get(kid);

            if(!parNode.outgoing.contains(kidNode)) 
            {
                parNode.outgoing.add(kidNode);
                kidNode.indegree++;
            }
        }

        node rootNode = null;
        for(int i:map.keySet())
        {
            if(map.containsKey(i) && map.get(i).indegree==0)
            {
                if(rootNode!=null)
                {
                    rootNode=null; break;
                }
                rootNode = map.get(i);
            }
        }
        if(rootNode==null) return null;

        HashSet<node> set = new HashSet<node>();
        LinkedList<node> q = new LinkedList<node>();

        q.addLast(rootNode);
        set.add(rootNode);
        while(!q.isEmpty())
        {
            node cur = q.removeFirst();
            for(node k : cur.outgoing)
            {
                if(set.contains(k))
                {
                    rootNode = null; break;
                }
                set.add(k); q.addLast(k);
            }
        }

        if(rootNode==null) return null;
        return (set.size()==map.size())?rootNode:null;
    }


========================================
(27). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/ReorderArray.java
========================================


Reorder array, so that a[i-1]<a[i]>a[i+1]


===
Print all results:

	boolean valid(int[] r, int k)
	{
		if(k==0 || k-1==0) return true;
		if(r[k]<r[k-1]) return r[k-1]>r[k-2];
		if(r[k]>r[k-1]) return r[k-1]<r[k-2];
		return false;
	}


	void helper(int[] a, int k,List<List<Integer>> re,  int[] r, boolean[] used)
	{
		int n = a.length;
		if(n==k)
		{
				List<Integer> rr = new ArrayList<Integer>();
				for(int i:r) rr.add(i);
				re.add(rr);
			return;
		}

		for(int i=0;i<n;i++)
		{
			if(!used[i])
			{
				used[i] = true;
				r[k] = a[i];
				if(valid(r,k))
				{
					
					helper(a,k+1,re, r, used);
				}
				used[i] = false;
			}
		}
		return;
	}

	List<List<Integer>> reOrder(int[] a)
	{
		List<List<Integer>> re = new ArrayList<List<Integer>>();
		int n = a.length;
		if(n==0) return re;

		helper(a, 0, re, new int[n], new boolean[n]);
		return re;
	}


---

	public void selection(int[] a, int k, int l, int r)
	{
		if(l+k>r) return;
		int val = a[l];

		int i = l-1, j = r+1;
		while(i<j)
		{
			while(++i<j && a[i]<=val);
			while(i<--j && a[j] >val);
			if(i>=j) break;

			int t = a[i];
			a[i] = a[j];
			a[j] = t;
		}
		int t = a[j];
		a[j] = a[l];
		a[l] = t;
		if(j-l == k) return;
		else if(j-l<k)
		{
			selection(a, k+l-j, j,r);
		}
		else
		{
			selection(a,k,l,j);
		}
	}

	void reverse(int[] a, int l, int r)
	{
		while(l<r)
		{
			int t = a[l]; a[l] = a[r]; a[r] = t;
			l++; r--;
		}
	}
	public void reorder(int[] a, int l, int r)
	{
		if(r-l+1<=2) return;

		int mid = l+(r-l)/2;

		int left = l +(mid-l)/2;
		int num = left-l+1;
		int right = mid+num;

		reverse(a, left+1, mid);
		reverse(a, mid+1, right);
		reverse(a,left+1, right);

		reorder(a, l, l+2*num-1);
		reorder(a, l+2*num, r);
	}

	public void reOrder(int[] a)
	{
		int n = a.length;
		if(n<=1) return;

		selection(a, (n-1)/2, 0, n-1);
		reorder(a,0,n-1);

	}


========================================
(28). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/reverseBit.java
========================================


/*Finally reverse bits of an integer.
*/

    int reverseInt(int val)
    {
        val = (val&(0xAAAAAAAA))>>1|((val&(0x55555555))<<1);
        val = (val&(0xCCCCCCCC))>>2|((val&(0x33333333))<<2);
        val = (val&(0xF0F0F0F0))>>4|((val&(0x0F0F0F0F0F))<<4);
        val = (val&(0xFF00FF00))>>8|((val&(0x00FF00FF))<<8);
        val = (val&(0xFFFF0000))>>16|((val&(0x0000FFFF))<<16);
        return val;
    }


========================================
(29). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/rotateBT.java
========================================


Given a binary tree where all the right nodes are leaf nodes, flip it 
upside down
* and turn it into a tree with left leaf nodes.
*
* for example, turn these:
*
*        1                1
*       /               / 
*      2   3            2   3
*     / 
*    4   5
*   / 
*  6   7
*
* into these:
*
*        1               1
*       /               /
*      2---3           2---3
*     /
*    4---5
*   /
*  6---7
*
* where 6 is the new root node for the left tree, and 2 for the right tree.
* oriented correctly:
*
*     6                  2
*    /                 / 
*   7   4              3   1
*      / 
*     5   2
*        / 
*       3   1
*/


---
  public TreeNode rotate(TreeNode root)
  {
      if(root == null) return null;

      if(root.left == null && root.right == null) return root;

      TreeNode newRoot =  rotate(root.left);
      root.left.left = root.right;
      root.left.right = root;
      root.left = null;
      root.right = null;
      return newRoot;
  }



========================================
(30). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/searchMatrix.java
========================================


/*
Given a sorted matrix where the number below and right of you will always be bigger, write an algorithm to find if a particular number 
exist in the matrix
*/


    boolean searchMatrix(int[][] a, int val)
    {
        int m = a.length;
        if(m==0) return false;
        int n = a[0].length;
        if(n==0) return false;

        int mm = 0, nn = n-1;
        while(mm<m&&nn>0)
        {
            int l = mm, r = m-1;
            int re1 = -1;
            while(l<=r)
            {
                int mid = l+(r-l)/2;
                if(a[mid][nn] == val) return true;
                else if(a[mid][nn] >val)
                {
                    re1 = mid; r = mid-1;
                }
                else l = mid+1;
            }
            if(re1==-1) return false;

            l = 0; r = nn;
            int re2 = -1;
            while(l<=r)
            {
                int mid = l+(r-l)/2;
                if(a[re1][mid]==val) return true;
                else if(a[re1][mid] > val)
                {
                    r = mid-1;
                }
                else
                {
                    re2 = mid;
                    l = mid+1;
                }
            }
            if(re2==-1) return false;

            mm = re1; nn = re2;
        }
        return false;
    }


========================================
(31). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/shortestPrefix.java
========================================


/*
Use the shorest unique prefix to represent each word in the array 
input: ["zebra", "dog", "duck",”dot”] 
output: {zebra: z, dog: do, duck: du} 

[zebra, dog, duck, dove] 
{zebra:z, dog: dog, duck: du, dove: dov} 

[bearcat, bear] 
{bearcat: bearc, bear: ""}

*/


  boolean compare(String s, String p, HashMap<String, String> map)
  {
    int m = s.length(), n=p.length();
    if(s.equals(p)) return true;

    int i=0;
    for(;i<m && i<n;i++)
    {
        if(s.charAt(i) < p.charAt(i))
        {
            String ss = map.get(s);
            String pp = map.get(p);
            if(ss.length()-1<i)
            {
                map.put(s,s.substring(0,i+1));
            }
            if(pp.length()-1<i)
            {
                map.put(p,p.substring(0,i+1));
            }
            return true;
        }
        else if(s.charAt(i) > p.charAt(i))
        {
            String ss = map.get(s);
            String pp = map.get(p);
            if(ss.length()-1<i)
            {
                map.put(s,s.substring(0,i+1));
            }
            if(pp.length()-1<i)
            {
                map.put(p,p.substring(0,i+1));
            }
            return false;
        }
    }

    if(s.length()-1<i)
    {
        map.put(s,s);
    }
    if(p.length()-1<i)
    {
        map.put(p,p);
    }
    return m<n;
  }

  int partition(String[] s, int l, int r, HashMap<String, String> map)
  {
    if(l>r) return -1;
    String val = s[l];
    int i=l-1, j=r+1;
    while(i<j)
    {
        while((++i)<j && compare(s[i], val, map));
        while((--j)>=i && !compare(s[j], val, map));
        if(i>j) break;
        String t = s[i];
        s[i] = s[j];
        s[j] = t;
    }
    String t = s[l];
    s[l] = s[j];
    s[j] = t;
    return j;
  }

  void sort(String[] s, int l, int r,HashMap<String, String> map)
  {
    if(l>r) return;
    
    int mid = partition(s,l,r, map);
    System.out.println("sort "+l+" "+r+", mid="+mid);
    sort(s,l,mid-1, map);
    sort(s,mid+1, r, map);
  }

  HashMap<String, String> func(String[] s)
  {
    HashMap<String, String> map = new HashMap<String, String>();
    int n = s.length;
    if(n==0) return map;

    for(String i:s)
    {
        map.put(i, "");
    }
    sort(s, 0, n-1, map);
    return map;
  }
  public static void main(String[] args) {
      String[] s ={"zero","dog","duck","dove"};
      System.out.println(new Solution().func(s));
  }
}


========================================
(32). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/uglyNumber.java
========================================


/*
Print out all the ugly number sequence below a certain number

Ugly Number is the product of only 2,3,5

Example: 1 2 3 4 5 6 8 9 10 12 
*/


    void uglyNumber(int N)
    {
        if(N<=0){ System.out.println(0); }
        else if(N==1) { System.out.println(1);}
        else
        {
            int[] re = new int[N];
            int cur = 0;
            int Two = 0, Three = 0, Five = 0;
            re[cur++] = 1;
            for(int i=1;i<N;i++)
            {
                int min = Math.min(re[Two]*2, Math.min(re[Three]*3,re[Five]*5));
                re[cur++] = min;
                while(re[Two]*2 <= min) Two++;
                while(re[Three]*3 <= min) Three++;
                while(re[Five]*5 <= min) Five++; 
            }
            for(int i:re)
                System.out.print(i+" ");
            System.out.println();
        }
    }
    public static void main(String[] args) {
        new Solution().uglyNumber(100);
    }
}



========================================
(33). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/UTF8Verification.java
========================================


/*
Designed a method to verify utf-8 characters
*/

boolean verify(String s)
{
	char[] c = s.toCharArray();

	int n = c.length;
	if(n==0) return false;

	int[] re = new int[n];

	for(int i=0;i<n;i++)
	{
		for(int j=i;j>=0;j--)
		{
			if(i-j+1>8) break;
			if(check(c[j], i-j+1) && (j==0 || re[j-1]==1)) re[i]=1;
		}
	}
	return re[n-1]==1;
}

boolean check(char c, int i)
{
	for(int j=7;j>=0;j--)
	{
		if( ((1<<7)&c) !=0 )
		{
			i--;
		}
		else break;
	}
	return i==0;
}



========================================
(34). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/winCoinPicking.java
========================================



You and opponent alternate picking gold pots out of line. You can pick either from the left 
or the right. All amounts of gold in all pots are know. Write an algorithm to pick the most 
gold. Assume you opponent is using the same algorithm.    

===

int winCoinPicking(int[] a)
    {
        int n = a.length;
        if(n==0) return 0;
        if(n==1) return a[0];

        return helper(a,0,n-1,new HashMap<Integer, Integer>());
    }

    int helper(int[] a, int l, int r, HashMap<Integer, Integer> map)
    {
        if(l>r) return 0;
        if(l==r) return a[l];

        int k = l*a.length+r;
        if(map.containsKey(k)) return map.get(k);
        int re = Math.max(a[l]+Math.min(helper(a,l+1,r-1,map), helper(a,l+1,r,map)) , a[r]+Math.min(helper(a,l,r-2,map), helper(a,l+1,r-1,map)));

        map.put(k,re);
        return re;
    }


========================================
(35). /Users/linxie/Documents/github/leetcodeV2/nonLeetCodeQ/youngTablueKMAX.java
========================================


给A，B 2个array，里面都是integer，已经排好序了，由大到小，他们的长度都是N

现在从A和B里各选出一个数，总成一个sum，请返回前N个最大的sum




class Pair implements Comparable
{
	int val, i, j;
	Pair(int _i, int _j, int ai, int bj)
	{
		val = ai+bj;
		i = _i; j = _j;
	}

	public int compareTo(Object o)
	{
		Pair p = (Pair)o;
		return val-p.val;
	}
}

class Solution
{
	public List<Integer> youngTablueKMAX(int[] a, int[] b, int k)
	{
		List<Integer> re = new ArrayList<Integer>();

		int m = a.length, n = b.length;
		if(k<=0 || k>=m*n) return re;

		if(k==1)
		{
			re.add(a[0]+b[0]);
			return re;
		}

		PriorityQueue<Pair> q = new PriorityQueue<Pair>();
		for(int i=0;i<n;i++)
		{
			q.add(new Pair(0,i,a[0], b[i]));
		}
		int count = 0;
		while(!q.isEmpty() && count<=k)
		{
			Pair cur = q.poll();
			if(cur == null) break;
			re.add(cur.val);

			cur.i++;
			if(cur.i == m) continue;

			q.add(new Pair(cur.i, cur.j, a[cur.i], b[cur.j]));
		}
		return re;
	}
}


