Find Minimum in Rotated Sorted Array

Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.

public class Solution {
    public int findMin(int[] num) {}
}

===


Maximum Product Subarray

Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.

public int maxProduct(int[] A)

====

Reverse Words in a String

Given an input string, reverse the string word by word.

For example,
Given s = "the sky is blue",
return "blue is sky the".

public String reverseWords(String s)

===

Evaluate Reverse Polish Notation

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

public int evalRPN(String[] tokens)

===

Max Points on a Line

public int maxPoints(Point[] points)

===

Sort List

public ListNode sortList(ListNode head)

==

Insertion Sort List

public ListNode insertionSortList(ListNode head)

===

LRU Cache

public class LRUCache {
    
    public LRUCache(int capacity)
    
    public int get(int key)
    
    public void set(int key, int value)

}

===

Binary Tree Postorder Traversal

public List<Integer> postorderTraversal(TreeNode root)

===

Binary Tree Preorder Traversal

public List<Integer> preorderTraversal(TreeNode root)

===

Reorder List

Given {1,2,3,4}, reorder it to {1,4,2,3}.

ListNode reverse(ListNode nd)

===

Linked List Cycle II

public ListNode detectCycle(ListNode head)

===

Linked List Cycle

public boolean hasCycle(ListNode head)

===

Word Break II

public List<String> wordBreak(String s, Set<String> dict)

===

Word Break

public boolean wordBreak(String s, Set<String> dict)

===

Copy List with Random Pointer

public RandomListNode copyRandomList(RandomListNode head)

===

Single Number II 
Given an array of integers, every element appears three

public int singleNumber(int[] A)

---

Single Number

public int singleNumber(int[] A)

==

Candy

public int candy(int[] ratings)

==

Gas Station

public int canCompleteCircuit(int[] gas, int[] cost)

===

Clone Graph

public UndirectedGraphNode cloneGraph(UndirectedGraphNode node)

===

Palindrome Partitioning II

public int minCut(String s)

===

Palindrome Partitioning

public  List<List<String>> partition(String s)

===

Surrounded Regions

void solve(char[][] board)

===

Sum Root to Leaf Numbers

public int sumNumbers(TreeNode root)

==

Longest Consecutive Sequence

public int longestConsecutive(int[] num)

===

Word Ladder II

public List<List<String>> findLadders(String start, String end, Set<String> dict)

===

Word Ladder

public int ladderLength(String start, String end, Set<String> dict)

===

Valid Palindrome

public boolean isPalindrome(String s)

===

Binary Tree Maximum Path Sum

public int maxPathSum(TreeNode root)

===

Best Time to Buy and Sell Stock III

public int maxProfit(int[] prices)

==

Best Time to Buy and Sell Stock II 

public int maxProfit(int[] prices)

===

Best Time to Buy and Sell Stock

public int maxProfit(int[] prices)

===

Triangle

Given a triangle, find the minimum path sum from top to bottom. 

public int minimumTotal(List<List<Integer>> triangle)

===

Pascal's Triangle II

For example, given k = 3,
Return [1,3,3,1].

public List<Integer> getRow(int rowIndex)

===

Pascal's Triangle

For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

public List<List<Integer>> generate(int numRows)

===

Populating Next Right Pointers in Each Node II 

public void connect(TreeLinkNode root)

===

Distinct Subsequences

S = "rabbbit", T = "rabbit"

Return 3.

public int numDistinct(String S, String T)

===

Flatten Binary Tree to Linked List

public void flatten(TreeNode root)

===

Path Sum II

public List<List<Integer>> pathSum(TreeNode root, int sum)

===

Minimum Depth of Binary Tree

public int minDepth(TreeNode root)

===

Balanced Binary Tree

public boolean isBalanced(TreeNode root)

===

Convert Sorted List to Binary Search Tree

public TreeNode sortedListToBST(ListNode head)

===

Convert Sorted Array to Binary Search Tree

public TreeNode sortedArrayToBST(int[] num)


===

Binary Tree Level Order Traversal II

public List<List<Integer>> levelOrderBottom(TreeNode root) // reverse

===

Construct Binary Tree from Inorder and Postorder Traversal

public TreeNode buildTree(int[] inorder, int[] postorder)

===

Construct Binary Tree from Preorder and Inorder Traversal

public TreeNode buildTree(int[] preorder, int[] inorder)

===

Maximum Depth of Binary Tree

public int maxDepth(TreeNode root)

===

Binary Tree Zigzag Level Order Traversal

public List<List<Integer>> zigzagLevelOrder(TreeNode root)

===

Binary Tree Level Order Traversal

public List<List<Integer>> levelOrder(TreeNode root)

===

Symmetric Tree

public boolean isSymmetric(TreeNode root)

===

Same Tree

public boolean isSameTree(TreeNode p, TreeNode q)

===




